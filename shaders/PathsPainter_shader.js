/* eslint-disable */
export default "precision mediump float;\r\nvarying vec2 vPosition;\r\nuniform mat3 uMatrixInverse;\r\nuniform sampler2D uData;\r\nuniform vec2 uTextureSize;\r\nuniform ivec4 uPathLength;\r\nuniform int uMaxPathLength;\r\nuniform int uActiveBodies;\r\nuniform mat4 uColorMatrix;\r\n\r\n// NOTE: This is best hardcoded as a constant (we could replace in JS if needed)\r\nconst int maxPathLength = 32 * 32 / 4;\r\n\r\nvec2 globalToModel( in vec2 modelPoint ) {\r\n  return ( uMatrixInverse * vec3( modelPoint, 1.0 ) ).xy;\r\n}\r\n\r\n// Given an index into our \"vec3 data array\", returns the vec3\r\nvec4 fetch( in int index ) {\r\n  vec2 coordinates = vec2( mod( float( index ), uTextureSize.x ), floor( float( index ) / uTextureSize.x ) );\r\n  return texture2D( uData, ( coordinates + 0.5 ) / uTextureSize );\r\n}\r\n\r\n// Signed distance to a line segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\r\n  vec2 pa = p-a, ba = b-a;\r\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n  return length( pa - ba*h );\r\n}\r\n\r\n// For one body, calculate the path stroke in a specific modelPosition\r\nvec4 getStroke( in vec2 modelPosition, in int bodyIndex, in vec3 planetColor ) {\r\n\r\n  float radius = 3.0;\r\n  float minDistance = 100000.0;\r\n\r\n  vec2 lastPosition = vec2( 0.0 );\r\n\r\n\r\n  int bodyPathLength =  ( bodyIndex == 0 ) ? uPathLength.x :\r\n                        ( bodyIndex == 1 ) ? uPathLength.y :\r\n                        ( bodyIndex == 2 ) ? uPathLength.z :\r\n                        ( bodyIndex == 3 ) ? uPathLength.w : 0;\r\n\r\n  float inversePathLength = 1.0 / float( bodyPathLength + 1 );\r\n\r\n  for ( int vertexIndex = 0; vertexIndex < maxPathLength; vertexIndex++ ) {\r\n    if ( vertexIndex >= bodyPathLength ) {\r\n      break;\r\n    }\r\n    vec2 position = fetch( bodyIndex * uMaxPathLength + vertexIndex ).xy;\r\n\r\n    if ( vertexIndex > 0 ) {\r\n      float dist = sdSegment( modelPosition, lastPosition, position );\r\n\r\n      minDistance = min( minDistance, dist + ( 1.0 - float( vertexIndex ) * inversePathLength ) * radius );\r\n    }\r\n\r\n    lastPosition = position;\r\n  }\r\n  return vec4( planetColor * smoothstep( radius, radius - 2.0, minDistance ), 0.0 );\r\n}\r\n\r\n// Returns the color from the vertex shader\r\nvoid main( void ) {\r\n  vec2 modelPosition = globalToModel( vPosition );\r\n  vec4 stroke = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n  for ( int bodyIndex = 0 ; bodyIndex < 4 ; bodyIndex++ ) {\r\n    if ( bodyIndex < uActiveBodies ){\r\n      stroke += getStroke( modelPosition, bodyIndex, uColorMatrix[ bodyIndex ].xyz );\r\n    }\r\n  }\r\n  gl_FragColor = stroke;\r\n}"