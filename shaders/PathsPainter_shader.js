/* eslint-disable */
export default "precision mediump float;\r\nvarying vec2 vPosition;\r\nuniform mat3 uMatrixInverse;\r\nuniform sampler2D uData;\r\nuniform vec2 uTextureSize;\r\nuniform int uPathLength;\r\nuniform int uMaxPathLength;\r\n\r\n// Signed distance to a line segment\r\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\r\n  vec2 pa = p-a, ba = b-a;\r\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\r\n  return length( pa - ba*h );\r\n}\r\n\r\n// Given an index into our \"vec3 data array\", returns the vec3\r\nvec4 fetch( in int index ) {\r\n  vec2 coordinates = vec2( mod( float( index ), uTextureSize.x ), floor( float( index ) / uTextureSize.x ) );\r\n  return texture2D( uData, ( coordinates + 0.5 ) / uTextureSize );\r\n}\r\n\r\nvec2 globalToModel( in vec2 modelPoint ) {\r\n  return ( uMatrixInverse * vec3( modelPoint, 1.0 ) ).xy;\r\n}\r\n\r\n// Given a distance to the line, return a vec4 color.\r\nvec4 distToValue( in float dist, in int closestIndex, in vec3 planetColor ) {\r\n  // divider = 0 when beggining. closestIndex == 0\r\n  // divider = 1 when ending. closestIndex == PathLength\r\n  float divider = float( closestIndex ) / float( uPathLength + 1 );\r\n  float value = smoothstep( 4.0 * divider, divider , dist );\r\n  // return vec4( vec3( value ), 0.9 );\r\n  return vec4( divider * planetColor, value * divider );\r\n}\r\n\r\n// For one body, calculate the path stroke in a specific modelPosition\r\nvec4 getStroke( in vec2 modelPosition, in int bodyIndex, in vec3 planetColor ) {\r\n  float dist = 1000.0;\r\n  int closestIndex = uPathLength;\r\n\r\n  for ( int vertexIndex = 0 ; vertexIndex < 1000 ; vertexIndex++ ) {\r\n    if ( ( vertexIndex == uPathLength - 1 ) || ( vertexIndex == uMaxPathLength - 1 ) ) {\r\n      return distToValue( dist, closestIndex, planetColor );\r\n    }\r\n    vec2 position0 = fetch( 4 + bodyIndex * uMaxPathLength + vertexIndex ).xy;\r\n    vec2 position1 = fetch( 4 + bodyIndex * uMaxPathLength + vertexIndex + 1 ).xy;\r\n\r\n    float newDistance = sdSegment( modelPosition, position0, position1 );\r\n    if ( newDistance < dist ) {\r\n      dist = newDistance;\r\n      closestIndex = vertexIndex;\r\n    }\r\n  }\r\n  return distToValue( dist, closestIndex, planetColor );\r\n}\r\n\r\n// Returns the color from the vertex shader\r\nvoid main( void ) {\r\n  vec2 modelPosition = globalToModel( vPosition );\r\n  vec4 stroke = vec4( 0.0 );\r\n  // for ( int bodyIndex = 0 ; bodyIndex < 4 ; bodyIndex++ ) {\r\n  //   stroke = getStroke( modelPosition, bodyIndex, fetch( bodyIndex ).xyz );\r\n  // }\r\n  stroke = getStroke( modelPosition, 1, fetch( 1 ).xyz );\r\n  gl_FragColor = stroke;\r\n}"